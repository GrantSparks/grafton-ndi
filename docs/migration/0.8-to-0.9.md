# Migration Guide: v0.8 to v0.9

This guide helps you upgrade from grafton-ndi v0.8 to v0.9. Version 0.9 focuses on ergonomic improvements and reducing boilerplate code, with one breaking change related to audio frame layout.

## Breaking Changes

### AudioFrameBuilder Default Layout

**Impact: Only affects users sending audio frames**

The `AudioFrameBuilder` now defaults to **planar layout** instead of interleaved (previously hardcoded to 0). This fixes completely broken audio sending functionality in v0.8.

**Before (v0.8 - broken):**
```rust
let audio_frame = AudioFrameBuilder::new()
    .sample_rate(48000)
    .num_channels(2)
    .num_samples(1920)
    .data(samples) // Assumed interleaved, but channel_stride was 0
    .build()?;
```

**After (v0.9 - working):**
```rust
// Option 1: Use planar layout (new default, recommended)
let audio_frame = AudioFrameBuilder::new()
    .sample_rate(48000)
    .num_channels(2)
    .num_samples(1920)
    .data(planar_samples) // All ch0, then all ch1
    .build()?;

// Option 2: Explicitly request interleaved layout
let audio_frame = AudioFrameBuilder::new()
    .sample_rate(48000)
    .num_channels(2)
    .num_samples(1920)
    .layout(AudioLayout::Interleaved) // Add this line
    .data(interleaved_samples) // ch0, ch1, ch0, ch1, ...
    .build()?;
```

**Why this change?**
- v0.8 had `channel_stride_in_bytes` hardcoded to 0, causing NDI SDK to reject audio
- FLTP (the NDI audio format) means "Float Planar", so planar is the correct default
- This change makes audio sending actually work

## New Features

### 1. SourceCache - Eliminate Discovery Boilerplate

**Before (v0.8):**
```rust
// ~150 lines of manual caching code in every application
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

struct MyCache {
    ndi: Arc<NDI>,
    sources: HashMap<String, Vec<Source>>,
}

impl MyCache {
    fn find_by_host(&mut self, host: &str) -> Result<Vec<Source>> {
        if let Some(cached) = self.sources.get(host) {
            return Ok(cached.clone());
        }

        let finder = Finder::new(&self.ndi, &FinderOptions::builder()
            .extra_ips(host)
            .build())?;
        finder.wait_for_sources(5000);
        let sources = finder.get_sources(0)?;

        // Filter for matching host...
        // Cache results...
        // Handle errors...
        // etc.
    }
}
```

**After (v0.9):**
```rust
use grafton_ndi::SourceCache;

let cache = SourceCache::new();
let sources = cache.find_by_host("192.168.1.100", 5000)?;

// That's it! NDI instance and sources are automatically cached
// Thread-safe, handles all edge cases
```

**Benefits:**
- Eliminates ~150 lines of boilerplate per application
- Thread-safe with interior mutability
- Handles NDI initialization automatically
- Methods: `new()`, `find_by_host()`, `invalidate()`, `clear()`, `len()`, `is_empty()`

### 2. Source Discovery Helpers

**New methods on `Source`:**
```rust
// Check if source matches a hostname or IP
if source.matches_host("192.168.1.100") {
    println!("Found matching source");
}

// Extract IP address
if let Some(ip) = source.ip_address() {
    println!("Source IP: {}", ip);
}

// Extract hostname without port
let host = source.host();
```

**New methods on `SourceAddress`:**
```rust
// Check if address contains a host/IP
if source.address.contains_host("192.168.1.100") {
    println!("Address matches");
}

// Parse port number
if let Some(port) = source.address.port() {
    println!("Port: {}", port);
}
```

### 3. Image Encoding (Optional Feature)

**Enable in Cargo.toml:**
```toml
[dependencies]
grafton-ndi = { version = "0.9", features = ["image-encoding"] }
```

**Usage:**
```rust
use grafton_ndi::ImageFormat;

let receiver = ReceiverOptions::builder(source).build(&ndi)?;

if let Some(video) = receiver.capture_video_blocking(5000)? {
    // One-line PNG encoding
    let png_bytes = video.encode_png()?;
    std::fs::write("frame.png", png_bytes)?;

    // JPEG with quality control
    let jpeg_bytes = video.encode_jpeg(85)?;

    // Base64 data URL for HTML/JSON
    let data_url = video.encode_data_url(ImageFormat::Jpeg(90))?;
    // Returns: "data:image/jpeg;base64,/9j/4AAQ..."
}
```

**Benefits:**
- Eliminates ~30 lines of encoding logic per application
- No need to add `png` or `jpeg-encoder` dependencies manually
- Automatic BGRA ↔ RGBA color conversion
- Stride validation prevents corrupted images

### 4. Reliable Frame Capture with Retry Logic

**Before (v0.8):**
```rust
// Manual retry loop (~40 lines per application)
let mut attempts = 0;
let max_attempts = 50;
let video = loop {
    if attempts >= max_attempts {
        return Err("Timeout".into());
    }

    match receiver.capture_video(100)? {
        Some(frame) => break frame,
        None => {
            attempts += 1;
            std::thread::sleep(Duration::from_millis(10));
        }
    }
};
```

**After (v0.9):**
```rust
// Recommended: Block until frame or timeout
let video = receiver.capture_video_blocking(5000)?
    .ok_or("No video within 5 seconds")?;

// Or: Fine-grained retry control
let video = receiver.capture_video_with_retry(100, 50)?
    .ok_or("No video after 50 attempts")?;
```

**Available for all frame types:**
- `capture_video_blocking(total_timeout_ms)` / `capture_video_with_retry(timeout_ms, max_attempts)`
- `capture_audio_blocking(total_timeout_ms)` / `capture_audio_with_retry(timeout_ms, max_attempts)`
- `capture_metadata_blocking(total_timeout_ms)` / `capture_metadata_with_retry(timeout_ms, max_attempts)`

**Benefits:**
- Handles NDI SDK timing quirks automatically
- Detailed timeout errors with attempt count and elapsed time
- 100ms per-attempt timeout with 10ms sleep between retries

### 5. Receiver Configuration Presets

**Before (v0.8):**
```rust
// Manual configuration for common use cases
let receiver = ReceiverOptions::builder(source)
    .color(ReceiverColorFormat::RGBX_RGBA)
    .bandwidth(ReceiverBandwidth::Lowest)
    .allow_video_fields(false)
    .build(&ndi)?;
```

**After (v0.9):**
```rust
use grafton_ndi::ReceiverOptionsBuilder;

// AI/image processing preset (low bandwidth, RGBA)
let receiver = ReceiverOptionsBuilder::snapshot_preset(source.clone())?
    .build(&ndi)?;

// Production preset (full resolution, highest bandwidth)
let receiver = ReceiverOptionsBuilder::high_quality_preset(source.clone())?
    .build(&ndi)?;

// Monitoring preset (metadata only, no video/audio)
let receiver = ReceiverOptionsBuilder::monitoring_preset(source)?
    .build(&ndi)?;
```

**Benefits:**
- Self-documenting API guides users to optimal settings
- Reduces configuration boilerplate
- Easy to customize: `snapshot_preset(source)?.name("Custom Name").build(&ndi)?`

### 6. Async Runtime Integration (Optional Features)

**Enable in Cargo.toml:**
```toml
[dependencies]
grafton-ndi = { version = "0.9", features = ["tokio"] }
# or
grafton-ndi = { version = "0.9", features = ["async-std"] }
```

**Usage:**
```rust
use grafton_ndi::AsyncReceiver;

#[tokio::main]
async fn main() -> Result<(), grafton_ndi::Error> {
    let source = /* ... discover source ... */;

    // Create async receiver
    let receiver = AsyncReceiver::new(
        ReceiverOptionsBuilder::snapshot_preset(source)?.build_async()?
    );

    // All capture methods are async
    if let Some(video) = receiver.capture_video_blocking(5000).await? {
        println!("Async frame: {}x{}", video.width, video.height);

        // Works seamlessly with image encoding
        #[cfg(feature = "image-encoding")]
        {
            let png = video.encode_png()?;
            tokio::fs::write("frame.png", png).await?;
        }
    }

    Ok(())
}
```

**Benefits:**
- Proper `spawn_blocking` usage prevents runtime blocking
- Arc-based sharing for async contexts (implements `Clone`)
- All 9 capture methods available (video/audio/metadata × 3 variants)

### 7. Instant Source Discovery

**New method on `Finder`:**
```rust
// Get immediate snapshot without additional network discovery
let sources = finder.get_current_sources()?;

// vs. get_sources() which performs network discovery
let sources = finder.get_sources(5000)?;
```

Available since NDI SDK 6.0. Useful for polling current state without blocking.

### 8. Enhanced Error Types

**New specific error variants:**
```rust
use grafton_ndi::Error;

match receiver.capture_video_blocking(5000) {
    Err(Error::FrameTimeout { attempts, elapsed }) => {
        eprintln!("Timeout after {} attempts in {:?}", attempts, elapsed);
    }
    Err(Error::SourceUnavailable { source_name }) => {
        eprintln!("Source '{}' went offline", source_name);
    }
    Err(Error::Disconnected { reason }) => {
        eprintln!("Receiver disconnected: {}", reason);
    }
    Ok(Some(frame)) => { /* process frame */ }
    Ok(None) => { /* no frame */ }
    Err(e) => { /* other errors */ }
}
```

**Benefits:**
- Rich error context for debugging
- Pattern matching friendly
- Targeted error recovery strategies

## Recommendations

### 1. Adopt SourceCache

Replace manual caching and discovery code:
```rust
// Old pattern
let mut cache: HashMap<String, (Arc<NDI>, Vec<Source>)> = HashMap::new();
// ... 150 lines of caching logic ...

// New pattern
let cache = SourceCache::new();
let sources = cache.find_by_host(host, 5000)?;
```

### 2. Use Blocking Capture Methods

Replace manual retry loops with built-in retry logic:
```rust
// Old pattern
loop {
    if let Some(frame) = receiver.capture_video(100)? {
        break frame;
    }
    // ... retry logic ...
}

// New pattern
let frame = receiver.capture_video_blocking(5000)?
    .ok_or("Timeout")?;
```

### 3. Use Presets for Common Configurations

```rust
// For AI/computer vision
ReceiverOptionsBuilder::snapshot_preset(source)?

// For production video processing
ReceiverOptionsBuilder::high_quality_preset(source)?

// For tally/status monitoring
ReceiverOptionsBuilder::monitoring_preset(source)?
```

### 4. Enable Optional Features as Needed

```toml
[dependencies]
grafton-ndi = { version = "0.9", features = [
    "image-encoding",  # If you encode frames to PNG/JPEG
    "tokio",          # If using Tokio async runtime
    # "async-std",    # Or if using async-std runtime
] }
```

### 5. Fix Audio Sending

If you send audio frames, verify the layout:
```rust
// If your data is planar (all ch0, then all ch1):
AudioFrameBuilder::new()
    .data(planar_samples)
    .build()?;  // Planar is now the default

// If your data is interleaved (ch0, ch1, ch0, ch1):
AudioFrameBuilder::new()
    .layout(AudioLayout::Interleaved)  // Must specify
    .data(interleaved_samples)
    .build()?;
```

## Example: Full Migration

**Before (v0.8):**
```rust
use grafton_ndi::{NDI, Finder, FinderOptions, ReceiverOptions, ReceiverColorFormat};
use std::time::Duration;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let ndi = NDI::new()?;

    // Manual source discovery
    let finder = Finder::new(&ndi, &FinderOptions::builder()
        .extra_ips("192.168.1.100")
        .build())?;
    finder.wait_for_sources(5000);
    let sources = finder.get_sources(0)?;

    let source = sources.iter()
        .find(|s| s.address.0.contains("192.168.1.100"))
        .ok_or("Source not found")?;

    // Manual configuration
    let receiver = ReceiverOptions::builder(source.clone())
        .color(ReceiverColorFormat::RGBX_RGBA)
        .build(&ndi)?;

    // Manual retry loop
    let mut attempts = 0;
    let video = loop {
        if attempts >= 50 {
            return Err("Timeout".into());
        }
        match receiver.capture_video(100)? {
            Some(frame) => break frame,
            None => {
                attempts += 1;
                std::thread::sleep(Duration::from_millis(10));
            }
        }
    };

    // Manual PNG encoding
    use png::{Encoder, ColorType};
    let mut encoder = Encoder::new(
        std::fs::File::create("frame.png")?,
        video.width as u32,
        video.height as u32,
    );
    encoder.set_color(ColorType::Rgba);
    let mut writer = encoder.write_header()?;

    // Convert BGRA to RGBA...
    // Handle stride...
    // Write data...

    Ok(())
}
```

**After (v0.9):**
```rust
use grafton_ndi::{SourceCache, ReceiverOptionsBuilder};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Automatic caching and discovery
    let cache = SourceCache::new();
    let sources = cache.find_by_host("192.168.1.100", 5000)?;
    let source = sources.first().ok_or("Source not found")?;

    // Use preset configuration
    let receiver = ReceiverOptionsBuilder::snapshot_preset(source.clone())?
        .build_from_cache(&cache)?;

    // Reliable capture with built-in retry
    let video = receiver.capture_video_blocking(5000)?
        .ok_or("No video frame")?;

    // One-line PNG encoding (requires "image-encoding" feature)
    #[cfg(feature = "image-encoding")]
    std::fs::write("frame.png", video.encode_png()?)?;

    Ok(())
}
```

**Result:**
- Code reduced from ~80 lines to ~15 lines
- Eliminated manual caching logic
- Eliminated manual retry loop
- Eliminated manual PNG encoding
- More readable and maintainable

## Testing Notes

The test suite has expanded from 13 to 28 tests in v0.9, covering:
- Source cache validation (4 tests)
- Source matching helpers (3 tests)
- Receiver presets (4 tests)
- Retry logic validation (2 tests)
- Audio layout handling (4 tests)

Run tests with:
```bash
cargo test --lib --doc          # Unit and doc tests (no NDI runtime required)
cargo test --all-features       # All tests including integration tests
```

## Platform Notes

### Linux
- Added architecture detection for NDI SDK library paths
- Automatically detects x86_64 vs aarch64 and selects correct library directory

### All Platforms
- Rust formatting and idiom improvements throughout
- Clippy warnings addressed
- Better documentation with real-world examples

## Summary

Version 0.9 is a significant ergonomic improvement over v0.8:
- **One breaking change**: AudioFrameBuilder defaults (easily fixed)
- **Massive reduction in boilerplate**: ~240 lines eliminated per typical application
- **Optional features**: Image encoding and async support don't increase core library size
- **Production ready**: More tests, better docs, real-world usage patterns

Upgrading is straightforward and the ergonomic improvements are worth it!
