# Migration Guide: v0.6 to v0.7

This guide helps you upgrade from grafton-ndi v0.6 to v0.7.

## Breaking Changes

### Audio Data Type Change

The most significant change in v0.7 is that audio data is now properly typed as 32-bit floats (`f32`) instead of raw bytes (`u8`). This matches the NDI v3 audio format (FLTP - 32-bit float planar).

#### Before (v0.6)
```rust
let audio_frame = recv.capture_audio(1000)?;
if let Some(frame) = audio_frame {
    let data: &[u8] = &frame.data;  // Raw bytes
    // Manual conversion needed to interpret as audio samples
}
```

#### After (v0.7)
```rust
let audio_frame = recv.capture_audio(1000)?;
if let Some(frame) = audio_frame {
    let data: &[f32] = frame.data();  // Properly typed as f32
    // Direct access to audio samples
    
    // New: Easy per-channel access
    if let Some(left_channel) = frame.channel_data(0) {
        // left_channel: Vec<f32>
    }
}
```

### AudioFrameBuilder Changes

When building audio frames, you now provide f32 samples directly:

#### Before (v0.6)
```rust
let frame = AudioFrame::builder()
    .data(vec![0u8; buffer_size])  // Raw bytes
    .build()?;
```

#### After (v0.7)
```rust
let frame = AudioFrame::builder()
    .data(vec![0.0f32; sample_count])  // f32 samples
    .build()?;
```

## New Features

### Channel Data Access

v0.7 adds a convenient method to extract audio data for specific channels:

```rust
let frame = recv.capture_audio(1000)?.unwrap();

// For stereo audio:
let left = frame.channel_data(0);   // Option<Vec<f32>>
let right = frame.channel_data(1);  // Option<Vec<f32>>

// Works with both interleaved and planar formats automatically
```

### Direct Float Access

Audio samples are now directly accessible as 32-bit floats:

```rust
let frame = recv.capture_audio(1000)?.unwrap();
let samples: &[f32] = frame.data();

// Calculate RMS
let rms = (samples.iter().map(|&x| x * x).sum::<f32>() / samples.len() as f32).sqrt();
```

## Common Migration Patterns

### Processing Audio Data

If you were manually converting bytes to floats:

```rust
// Before
let bytes = &frame.data;
let floats: Vec<f32> = bytes.chunks_exact(4)
    .map(|chunk| f32::from_le_bytes([chunk[0], chunk[1], chunk[2], chunk[3]]))
    .collect();

// After
let floats = frame.data(); // Already f32!
```

### Working with External Libraries

If passing to external audio processing libraries:

```rust
// Before
external_lib.process_audio(
    frame.data.as_ptr() as *const f32,
    frame.no_samples as usize
);

// After
external_lib.process_audio(
    frame.data().as_ptr(),
    frame.no_samples as usize
);
```

## Benefits of This Change

1. **Type Safety**: No more casting or manual conversions
2. **Performance**: Direct access to properly typed data
3. **Convenience**: Built-in channel extraction
4. **Correctness**: Matches NDI SDK v3 audio format exactly

## Need Help?

If you encounter any issues during migration, please open an issue on our [GitHub repository](https://github.com/GrantSparks/grafton-ndi).